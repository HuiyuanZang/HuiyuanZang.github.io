# the stacks used in Linux on Arm64

## IRQ stack

on ARM64 architecture, the Linux kernel uses a separate stack for handling interrupts (IRQs) instead of using the kernel stack of the current process.

This is because handling an interrupt requires the kernel to execute a special type of code called an interrupt service routine (ISR) or an interrupt handler. ISRs are executed in the context of the interrupt that triggered them, and they must execute quickly and without interfering with the normal operation of the system.

Using a separate stack for IRQs allows the kernel to isolate the interrupt handling code from the rest of the system and ensure that it executes quickly and reliably. The IRQ stack is typically a dedicated region of memory that is reserved for interrupt handling and is not used by normal program execution.

When an interrupt occurs, the CPU automatically switches to the IRQ stack and starts executing the ISR. The ISR can access data and functions in the kernel as needed, but it cannot access the stack or data of the interrupted process.

By using a separate stack for IRQs, the Linux kernel can ensure that interrupt handling is fast, efficient, and reliable, even in the presence of multiple interrupts occurring simultaneously.

## Exception Stack 

When an exception occurs on ARM64, such as a data abort or a page fault, the CPU stops executing the current program and transfers control to the appropriate exception handler routine in the kernel. Like ISRs, exception handlers must execute quickly and without interfering with the normal operation of the system.

To ensure efficient and reliable handling of exceptions, the Linux kernel uses a separate stack called the exception stack or the kernel stack for exceptions. This stack is also typically a dedicated region of memory that is reserved for exception handling and is not used by normal program execution.

The exception stack is similar to the IRQ stack in that it allows the kernel to isolate exception handling from normal program execution and ensure that exception handlers execute quickly and reliably. However, the exception stack is used specifically for handling exceptions, while the IRQ stack is used specifically for handling interrupts.

Overall, using separate stacks for IRQs and exceptions allows the Linux kernel to efficiently and reliably handle a wide range of events and ensure the stability and reliability of the system.

## softirq stack

on Linux, softirqs also use a separate stack called the softirq stack, which is another dedicated region of memory reserved for softirq processing.

Softirqs are a type of interrupt that is generated by the kernel itself in response to certain events, such as network packet reception or completion of disk I/O. Like IRQs, softirqs must be processed quickly and efficiently to prevent system slowdown or instability.

To ensure efficient processing of softirqs, the Linux kernel uses a separate stack called the softirq stack. This stack is also typically a dedicated region of memory that is not used by normal program execution. When a softirq is generated, the kernel transfers control to the appropriate softirq handler routine, which executes on the softirq stack.

Using a separate stack for softirqs allows the kernel to isolate softirq processing from other parts of the system and ensure that softirq handlers execute quickly and without interfering with normal program execution. This helps to prevent system slowdown or instability and ensures the stability and reliability of the system.


## hardirq_stack array and softirq_stack array 


All hard IRQ stacks are contained in the **hardirq_stack** array, while all soft IRQ
stacks are contained in the **softirq_stack** array.Each array element is a union of type
**irq_ctx** that span a single page. At the bottom of this page is stored a thread_info
structure, while the spare memory locations are used for the stack; remember that
each stack grows towards lower addresses. Thus, hard IRQ stacks and soft IRQ
stacks are very similar to the exception stacks. The only difference is that the thread_info structure coupled
with each stack is associated with a CPU rather than a process.

The hardirq_ctx and softirq_ctx arrays allow the kernel to quickly determine the
hard IRQ stack and soft IRQ stack of a given CPU, respectively: they contain point-
ers to the corresponding irq_ctx elements.




## process context--user mode stack of a process and kernel mode stadk of a process 

On ARM64 architecture, each process has two separate stacks: a user mode stack and a kernel mode stack.

The user mode stack is used when the process is executing in user mode, which is when it is running normal application code. The user mode stack contains the function call frames for user-level code, including any local variables, arguments, and return addresses. When a function is called from user mode, the stack grows downward, and when a function returns, the stack shrinks upward.

The kernel mode stack, on the other hand, is used when the process is executing in kernel mode, which is when it is executing kernel code in response to a system call, interrupt, or exception. The kernel mode stack is used to store the function call frames for kernel-level code, including any local variables, arguments, and return addresses. When a system call is made, the kernel switches from the user mode stack to the kernel mode stack, and when the system call returns, it switches back to the user mode stack.

Both the user mode stack and the kernel mode stack are separate from the stack used for IRQs, exceptions, and softirqs, as I mentioned in my previous answer. By using separate stacks for different contexts, the ARM64 architecture allows for efficient and reliable execution of both user-level and kernel-level code, as well as handling of various types of events and interrupts.