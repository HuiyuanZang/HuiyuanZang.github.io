# Interrrupt Descriptor Table(IDT) on X86 Vs Exception Vector table(EVT) on Arm64

One key difference between the IDT and EVT is that the IDT includes separate entries for interrupts and exceptions, while the EVT includes entries for all types of exceptions, including IRQs, FIQs, and system calls.

## IDT
The IDT is a data structure used by the CPU to handle interrupts and exceptions. When an interrupt or exception occurs, the CPU looks up the corresponding entry in the IDT to find the address of the interrupt or exception handler.On x86 architecture, the IDT is stored in memory as a contiguous array of 8-byte entries, each describing an interrupt or exception handler.

For the detail, we can refer to the Chapter 4 of UnderStanding The Linux Kernel 3rd 

**Task, Interrupt, and Trap Gate Descriptors**


- Interrupt gate
An Intel interrupt gate that cannot be accessed by a User Mode process (the
gate’s DPL field is equal to 0). All Linux interrupt handlers are activated by
means of interrupt gates, and all are restricted to Kernel Mode.
- System gate
An Intel trap gate that can be accessed by a User Mode process (the gate’s DPL
field is equal to 3). The three Linux exception handlers associated with the vec-
tors 4, 5, and 128 are activated by means of system gates, so the three assembly
language instructions into, bound, and int $0x80 can be issued in User Mode.
- System interrupt gate
An Intel interrupt gate that can be accessed by a User Mode process (the gate’s
DPL field is equal to 3). The exception handler associated with the vector 3 is
activated by means of a system interrupt gate, so the assembly language instruc-
tion int3 can be issued in User Mode.
- Trap gate
An Intel trap gate that cannot be accessed by a User Mode process (the gate’s
DPL field is equal to 0). Most Linux exception handlers are activated by means
of trap gates.
- Task gate
An Intel task gate that cannot be accessed by a User Mode process (the gate’s
DPL field is equal to 0). The Linux handler for the “Double fault” exception is
activated by means of a task gate.

## EVT

On the other hand, the EVT is used on ARM64 architecture and is an array of 64-bit pointers to exception handlers stored in memory. The EVT is similar in concept to the IDT, but the implementation is different due to the differences in CPU architecture. When an exception occurs, the CPU looks up the corresponding entry in the EVT to find the address of the handler.

For example, on ARM64, the first entry in the EVT (index 0) is reserved for reset exceptions, which occur when the CPU is reset. The second entry (index 1) is reserved for undefined instruction exceptions, which occur when the CPU encounters an instruction that it doesn't recognize.

Other entries in the EVT are used to handle specific types of exceptions, such as IRQs and FIQs. IRQs are interrupt requests generated by external devices, such as keyboards, mice, or network cards. FIQs (Fast Interrupt Requests) are similar to IRQs but are given a higher priority and are intended for time-critical tasks.

When an exception occurs, the CPU uses the corresponding entry in the EVT to find the address of the exception handler. The CPU then saves the current program state (registers, flags, etc.) and jumps to the exception handler.

In addition to handling exceptions, the EVT is also used to handle other events, such as virtual memory faults and debug exceptions. Virtual memory faults occur when a program tries to access a memory address that is not currently mapped to physical memory. Debug exceptions occur when a program executes a breakpoint instruction or encounters a hardware debug event.

Overall, the EVT is an important data structure used by ARM64 CPUs to handle various types of exceptions and events. It provides a way for the CPU to quickly and efficiently handle these events and recover from errors or unexpected behavior.

On ARM64 architecture, each entry in the Exception Vector Table (EVT) is 64 bits (8 bytes) in size. This is the same size as a pointer on ARM64.

Each 64-bit entry in the EVT contains the address of the corresponding exception handler. When an exception occurs, the CPU looks up the appropriate entry in the EVT to find the address of the handler.

The EVT is a data structure used by ARM64 CPUs to handle various types of exceptions, including IRQs, FIQs, system calls, and virtual memory faults. It provides a way for the CPU to quickly and efficiently handle these events and recover from errors or unexpected behavior.

The size of the EVT itself varies depending on the specific ARM64 processor and system configuration. The EVT is typically located in a fixed location in memory and is initialized during system boot. The size and layout of the EVT are determined by the processor architecture and the specific operating system running on the system.

in the Linux kernel code, the Exception Vector Table (EVT) is defined in the arch/arm64/kernel/entry.S assembly file. This file contains the assembly code for the ARM64 exception and interrupt handling routines, including the code that sets up the EVT.

Specifically, the arch/arm64/kernel/entry.S file defines the vectors label, which is the starting address of the EVT. The EVT is an array of 64-bit pointers to exception handlers, where each entry in the array corresponds to a specific type of exception or interrupt.

Here's an example of the code that sets up the EVT in arch/arm64/kernel/entry.S:

```C
.section .vectors, "ax"
.align 13
vectors:
	adr	x19, reset_vector
	adr	x20, undefined_instruction_vector
	adr	x21, software_interrupt_vector
	adr	x22, prefetch_abort_vector
	adr	x23, data_abort_vector
	adr	x24, reserved_vector
	adr	x25, irq_vector
	adr	x26, fiq_vector

	// ... more entries for other exceptions and interrupts ...

```
This code defines the vectors label as the starting address of the EVT and then sets up the addresses for various exception and interrupt handlers by using the adr instruction to load the addresses of the corresponding labels into registers.

Overall, the arch/arm64/kernel/entry.S file is a key component of the ARM64 architecture in the Linux kernel and is responsible for handling exceptions and interrupts by setting up the EVT and invoking the appropriate exception handlers.

The size of the Exception Vector Table (EVT) on ARM64 architecture can vary depending on the specific processor and system configuration. The EVT is typically located in a fixed location in memory and is initialized during system boot.

In general, the size of the EVT is determined by the number of entries it contains, where each entry is 64 bits (8 bytes) in size. The number of entries in the EVT depends on the specific ARM64 processor and the system configuration, which determines the types of exceptions and interrupts that need to be handled.

For example, on the ARMv8-A architecture, the EVT typically contains entries for reset, undefined instruction, software interrupt, prefetch abort, data abort, reserved, IRQ, and FIQ exceptions. Additional entries may be added for other types of exceptions or for specific system configurations.

The size of the EVT is important because it affects the amount of memory used by the kernel to store the EVT and the amount of time it takes for the CPU to look up the appropriate entry in the table when an exception occurs. However, the size of the EVT is typically not a major concern for most systems, as it is usually relatively small compared to the overall system memory and does not significantly impact system performance.